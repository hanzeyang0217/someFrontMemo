# 函数入门

1. 定义一个函数
   ```javascript
   //具名函数
   function 函数名 (形参1，形参2){
   语句
   return
   }
   //匿名函数
   let fn = function(x,y){
   return x + y
   }
   //箭头函数
   let fn = (x,y) => x + y
   let fn = (x,y) => {return x + y}
   let fn = (x,y) => ({name: x, age:y}) //一定要括号
   ```
2. 函数调用
   - `fn()`
3. 函数的要素

   - 调用时机
     - 就是说看清楚什么时候调用的
     - 这边会牵扯到异步的时间的问题 //`setTimeout`
     - 经典`6个6`
   - 作用域
     - 以前屁事蛮多的`var`
     - 现在知道`就近原则`就好了 //小学生都会
   - 闭包
     - `如果一个函数用到了外部的变量那么这个函数加这个变量就叫闭包`
     - 具体就是不管执行时机，函数体生成的时候用到的变量的`当时的值`会被一起保存 而不是实际执行的时候去找那个变量`现在的值`
     - [更详细的攻略](./闭包/闭包.md)
   - 形参
     - 就是函数里的变量声明
     - `var 变量1 = arguments[0]`
     - `var 变量2 = arguments[1]`
     - 的概念
     - 靠执行时候传`实参`
   - 返回值
     - 很重要！！！
     - 每个函数都有返回值
     - 默认返回 `undefined`
     - 只有函数有返回值
     - `1+2`不是返回值是`3` 而是值是`3`
   - 调用栈
     - 压栈压栈压栈！！！
     - `push && pop`
     - MAX V8 1w2 千多点
     - 爆栈！！！递归的时候小心呀
   - 函数提升
     - 函数声明在执行前(就是预编译的时候)会被提前声明好
     - 但是`let fn = function(){}`是赋值不是声明哟 所以不会被提升
   - `arguments`//`箭头函数没有`
     - 就是放着`实参值`的数组
   - this//`箭头函数没有`
     - 普通调用的时候
       - 比如 `person.sayHi()`
       - 自动生成`this` 指向`person`
       - 当作实参传进函数
     - 我们用`fn.call(fn,1,2,3)`来自己传

4. 立即执行函数

   - 不要用`()`用`！`
   - 因为 可以因为上文 而杯具
   - 话说为啥会诞生这个语法是因为
     - 当时(ES5)需要局部变量，就必须引入一个函数
     - 但是很蠢的就是，引入的那个函数不是也占了一个名字嘛。。
     - 于是开发者们研究出来这个语法
     - 实现了 `局部变量` 和 `不增加新的名字` 的愿望
     - 现在不需要吧。。
